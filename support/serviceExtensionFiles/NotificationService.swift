//
//  NotificationService.swift
//  NotificationServiceExtension
//
//  Generated by expo-notification-service-extension-plugin
//

import UserNotifications
import Intents
import UIKit

class NotificationService: UNNotificationServiceExtension {
    
    var contentHandler: ((UNNotificationContent) -> Void)?
    var bestAttemptContent: UNMutableNotificationContent?
    var urlSession: URLSession?
    
    override init() {
        super.init()
        NSLog("üîî NotificationService: Swift extension initialized successfully!")
    }
    
    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {
        NSLog("üîî NotificationService: ============== EXTENSION TRIGGERED ==============")
        NSLog("üîî NotificationService: Request identifier: %@", request.identifier)
        NSLog("üîî NotificationService: Original title: %@", request.content.title)
        NSLog("üîî NotificationService: Original body: %@", request.content.body)
        NSLog("üîî NotificationService: UserInfo: %@", request.content.userInfo)
        
        self.contentHandler = contentHandler
        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)
        
        guard let bestAttemptContent = bestAttemptContent else {
            NSLog("üîî NotificationService: ERROR - bestAttemptContent is nil")
            contentHandler(request.content)
            return
        }
        
        // Check if this is a communication notification
        if isCommunicationNotification(request: request) {
            NSLog("üîî NotificationService: üì± Communication notification detected")
            processCommunicationNotification(content: bestAttemptContent, request: request)
        } else {
            NSLog("üîî NotificationService: Regular notification - checking for custom attachments")
            if let iconUrl = extractCustomIconUrl(from: request.content.userInfo) {
                downloadAndAttachImage(iconUrl: iconUrl) { [weak self] success in
                    if success {
                        NSLog("üîî NotificationService: ‚úÖ Custom icon attached successfully")
                    } else {
                        NSLog("üîî NotificationService: ‚ùå Failed to attach custom icon")
                    }
                    self?.finishWithContent()
                }
            } else {
                finishWithContent()
            }
        }
    }
    
    override func serviceExtensionTimeWillExpire() {
        NSLog("üîî NotificationService: serviceExtensionTimeWillExpire called")
        finishWithContent()
    }
    
    // MARK: - Communication Notification Processing
    
    private func isCommunicationNotification(request: UNNotificationRequest) -> Bool {
        let userInfo = request.content.userInfo
        
        // Check for communication_intent at root level
        if userInfo["communication_intent"] != nil {
            NSLog("üîî NotificationService: üí¨ Communication notification detected via communication_intent")
            return true
        }
        
        // Check for type field
        if let type = userInfo["type"] as? String, type == "communication" {
            return true
        }
        
        // Check in data object
        if let data = userInfo["data"] as? [String: Any],
           let type = data["type"] as? String, type == "communication" {
            return true
        }
        
        // Check for sender information
        if let senderName = userInfo["sender_name"] as? String,
           let senderId = userInfo["sender_id"] as? String,
           !senderName.isEmpty, !senderId.isEmpty {
            NSLog("üîî NotificationService: üí¨ Communication notification detected via sender info")
            return true
        }
        
        return false
    }
    
    private func processCommunicationNotification(content: UNMutableNotificationContent, request: UNNotificationRequest) {
        NSLog("üîî NotificationService: üì± Processing communication notification...")
        
        // Only process on iOS 15+
        guard #available(iOS 15.0, *) else {
            NSLog("üîî NotificationService: ‚ö†Ô∏è Communication notifications require iOS 15+")
            fallbackToRegularNotification(content: content, request: request)
            return
        }
        
        let userInfo = request.content.userInfo
        var communicationData: [String: Any] = [:]
        
        // Extract communication data from different possible locations
        if let communicationIntent = userInfo["communication_intent"] as? [String: Any] {
            communicationData = communicationIntent
        } else if let data = userInfo["data"] as? [String: Any] {
            communicationData = data
        } else {
            // Extract from root level
            communicationData = userInfo
        }
        
        guard let senderName = extractSenderName(from: communicationData),
              let senderId = extractSenderId(from: communicationData) else {
            NSLog("üîî NotificationService: ‚ùå Missing required sender information")
            fallbackToRegularNotification(content: content, request: request)
            return
        }
        
        let conversationId = extractConversationId(from: communicationData)
        let isGroup = extractIsGroup(from: communicationData)
        let groupName = extractGroupName(from: communicationData)
        
        NSLog("üîî NotificationService: üì± Sender: %@, Group: %@, Conversation: %@", senderName, isGroup ? "YES" : "NO", conversationId)
        
        // Create the communication notification
        createCommunicationNotification(
            content: content,
            senderName: senderName,
            senderId: senderId,
            conversationId: conversationId,
            isGroup: isGroup,
            groupName: groupName,
            messageBody: content.body,
            request: request
        )
    }
    
    private func createCommunicationNotification(
        content: UNMutableNotificationContent,
        senderName: String,
        senderId: String,
        conversationId: String,
        isGroup: Bool,
        groupName: String?,
        messageBody: String,
        request: UNNotificationRequest
    ) {
        // Create sender person with proper name components
        let handle = INPersonHandle(value: senderId, type: .unknown)
        
        var personNameComponents = PersonNameComponents()
        let nameComponents = senderName.components(separatedBy: " ")
        if nameComponents.count > 1 {
            personNameComponents.givenName = nameComponents[0]
            personNameComponents.familyName = nameComponents.dropFirst().joined(separator: " ")
        } else {
            personNameComponents.nickname = senderName
        }
        
        // Create sender image
        let senderImage = createSenderImage(for: senderName)
        let senderINImage = INImage(imageData: senderImage.pngData()!)
        
        let senderPerson = INPerson(
            personHandle: handle,
            nameComponents: personNameComponents,
            displayName: senderName,
            image: senderINImage,
            contactIdentifier: nil,
            customIdentifier: senderId,
            isMe: false,
            suggestionType: .none
        )
        
        // Create recipient (current user)
        let meHandle = INPersonHandle(value: "current-user", type: .unknown)
        let mePerson = INPerson(
            personHandle: meHandle,
            nameComponents: nil,
            displayName: nil,
            image: nil,
            contactIdentifier: nil,
            customIdentifier: "current-user",
            isMe: true,
            suggestionType: .none
        )
        
        // Create recipients array
        var recipients = [mePerson]
        
        // For group messages, add additional recipients
        if isGroup {
            let otherHandle = INPersonHandle(value: "other-user", type: .unknown)
            let otherPerson = INPerson(
                personHandle: otherHandle,
                nameComponents: nil,
                displayName: "Other User",
                image: nil,
                contactIdentifier: nil,
                customIdentifier: "other-user",
                isMe: false,
                suggestionType: .none
            )
            recipients.append(otherPerson)
        }
        
        // Create speakable group name if group
        var speakableGroupName: INSpeakableString?
        var groupImage: INImage?
        
        if isGroup {
            let finalGroupName = groupName ?? "Group Chat"
            speakableGroupName = INSpeakableString(spokenPhrase: finalGroupName)
            groupImage = createGroupImage()
        }
        
        // Create the message intent
        let intent = INSendMessageIntent(
            recipients: recipients,
            outgoingMessageType: .outgoingMessageText,
            content: messageBody,
            speakableGroupName: speakableGroupName,
            conversationIdentifier: conversationId,
            serviceName: nil,
            sender: senderPerson,
            attachments: nil
        )
        
        // Set images
        intent.setImage(senderINImage, forParameterNamed: \.sender)
        if let groupImage = groupImage {
            intent.setImage(groupImage, forParameterNamed: \.speakableGroupName)
        }
        
        // Donate interaction
        donateInteraction(intent: intent) { [weak self] success in
            if success {
                self?.updateNotificationContent(content: content, intent: intent, conversationId: conversationId, request: request)
            } else {
                NSLog("üîî NotificationService: ‚ùå Failed to donate interaction")
                self?.fallbackToRegularNotification(content: content, request: request)
            }
        }
    }
    
    @available(iOS 15.0, *)
    private func updateNotificationContent(content: UNMutableNotificationContent, intent: INSendMessageIntent, conversationId: String, request: UNNotificationRequest) {
        do {
            NSLog("üîî NotificationService: üì± Updating notification content from intent")
            
            // Use the iOS 15+ method to update content from intent
            let updatedContent = try content.updating(from: intent)
            
            guard let mutableContent = updatedContent.mutableCopy() as? UNMutableNotificationContent else {
                NSLog("üîî NotificationService: ‚ùå Could not create mutable content")
                fallbackToRegularNotification(content: content, request: request)
                return
            }
            
            // Configure the updated content
            mutableContent.threadIdentifier = conversationId
            mutableContent.categoryIdentifier = "COMMUNICATION_MESSAGE"
            mutableContent.sound = mutableContent.sound ?? .default
            mutableContent.userInfo = request.content.userInfo
            
            NSLog("üîî NotificationService: ‚úÖ Communication notification created successfully")
            NSLog("üîî NotificationService: Final title: %@", mutableContent.title)
            NSLog("üîî NotificationService: Final body: %@", mutableContent.body)
            
            bestAttemptContent = mutableContent
            finishWithContent()
            
        } catch {
            NSLog("üîî NotificationService: ‚ùå Error updating content from intent: %@", error.localizedDescription)
            fallbackToRegularNotification(content: content, request: request)
        }
    }
    
    private func donateInteraction(intent: INSendMessageIntent, completion: @escaping (Bool) -> Void) {
        let interaction = INInteraction(intent: intent, response: nil)
        interaction.direction = .incoming
        interaction.dateInterval = DateInterval(start: Date(), duration: 1.0)
        
        NSLog("üîî NotificationService: üì± Donating interaction...")
        
        interaction.donate { error in
            if let error = error {
                NSLog("üîî NotificationService: ‚ùå Donation failed: %@", error.localizedDescription)
                completion(false)
            } else {
                NSLog("üîî NotificationService: ‚úÖ Donation successful")
                completion(true)
            }
        }
    }
    
    // MARK: - Helper Methods
    
    private func extractSenderName(from data: [String: Any]) -> String? {
        return data["sender_name"] as? String ?? data["senderName"] as? String
    }
    
    private func extractSenderId(from data: [String: Any]) -> String? {
        return data["sender_id"] as? String ?? data["senderId"] as? String
    }
    
    private func extractConversationId(from data: [String: Any]) -> String {
        return data["conversation_id"] as? String ?? data["conversationId"] as? String ?? "default-conversation"
    }
    
    private func extractIsGroup(from data: [String: Any]) -> Bool {
        if let isGroup = data["is_group"] as? Bool {
            return isGroup
        }
        if let isGroup = data["isGroup"] as? Bool {
            return isGroup
        }
        if let isGroup = data["is_group"] as? NSNumber {
            return isGroup.boolValue
        }
        if let isGroup = data["isGroup"] as? NSNumber {
            return isGroup.boolValue
        }
        return false
    }
    
    private func extractGroupName(from data: [String: Any]) -> String? {
        return data["group_name"] as? String ?? data["groupName"] as? String
    }
    
    private func createSenderImage(for senderName: String) -> UIImage {
        let size = CGSize(width: 60, height: 60)
        let renderer = UIGraphicsImageRenderer(size: size)
        
        return renderer.image { context in
            // Create a circular background with color based on sender name
            let colors: [UIColor] = [.systemBlue, .systemPurple, .systemGreen, .systemOrange, .systemRed, .systemTeal, .systemIndigo]
            let colorIndex = abs(senderName.hashValue) % colors.count
            colors[colorIndex].setFill()
            context.cgContext.fillEllipse(in: CGRect(origin: .zero, size: size))
            
            // Add initials
            let initials = extractInitials(from: senderName)
            let font = UIFont.systemFont(ofSize: 24, weight: .medium)
            let attributes: [NSAttributedString.Key: Any] = [
                .font: font,
                .foregroundColor: UIColor.white
            ]
            
            let textSize = initials.size(withAttributes: attributes)
            let textRect = CGRect(
                x: (size.width - textSize.width) / 2,
                y: (size.height - textSize.height) / 2,
                width: textSize.width,
                height: textSize.height
            )
            
            initials.draw(in: textRect, withAttributes: attributes)
        }
    }
    
    private func createGroupImage() -> UIImage {
        let size = CGSize(width: 60, height: 60)
        let renderer = UIGraphicsImageRenderer(size: size)
        
        return renderer.image { context in
            // Create a circular background
            UIColor.systemIndigo.setFill()
            context.cgContext.fillEllipse(in: CGRect(origin: .zero, size: size))
            
            // Add multiple small circles to represent group
            let smallCircleSize: CGFloat = 16
            let positions = [
                CGPoint(x: 15, y: 15),
                CGPoint(x: 35, y: 15),
                CGPoint(x: 25, y: 35)
            ]
            
            UIColor.white.setFill()
            for position in positions {
                context.cgContext.fillEllipse(in: CGRect(
                    x: position.x,
                    y: position.y,
                    width: smallCircleSize,
                    height: smallCircleSize
                ))
            }
        }
    }
    
    private func extractInitials(from name: String) -> String {
        let words = name.components(separatedBy: .whitespacesAndNewlines)
            .filter { !$0.isEmpty }
        
        if words.count >= 2 {
            return String(words[0].prefix(1) + words[1].prefix(1)).uppercased()
        } else if let firstWord = words.first {
            return String(firstWord.prefix(2)).uppercased()
        } else {
            return "?"
        }
    }
    
    // MARK: - Image Attachment (for non-communication notifications)
    
    private func extractCustomIconUrl(from userInfo: [AnyHashable: Any]) -> String? {
        // Check root level
        if let iconUrl = userInfo["custom_icon_url"] as? String {
            return iconUrl
        }
        
        // Check in data object
        if let data = userInfo["data"] as? [String: Any],
           let iconUrl = data["custom_icon_url"] as? String {
            return iconUrl
        }
        
        // Check in body object
        if let body = userInfo["body"] as? [String: Any],
           let iconUrl = body["custom_icon_url"] as? String {
            return iconUrl
        }
        
        return nil
    }
    
    private func downloadAndAttachImage(iconUrl: String, completion: @escaping (Bool) -> Void) {
        guard let url = URL(string: iconUrl) else {
            NSLog("üîî NotificationService: Invalid icon URL: %@", iconUrl)
            completion(false)
            return
        }
        
        if urlSession == nil {
            let config = URLSessionConfiguration.default
            config.timeoutIntervalForRequest = 10.0
            urlSession = URLSession(configuration: config)
        }
        
        urlSession?.dataTask(with: url) { [weak self] data, response, error in
            guard let self = self,
                  let data = data,
                  error == nil else {
                NSLog("üîî NotificationService: Failed to download image: %@", error?.localizedDescription ?? "Unknown error")
                completion(false)
                return
            }
            
            self.processImageData(data: data, response: response, completion: completion)
        }.resume()
    }
    
    private func processImageData(data: Data, response: URLResponse?, completion: @escaping (Bool) -> Void) {
        // Create temporary file
        let tempDir = NSTemporaryDirectory()
        let fileName = "notification_image_\(UUID().uuidString).png"
        let filePath = (tempDir as NSString).appendingPathComponent(fileName)
        
        do {
            try data.write(to: URL(fileURLWithPath: filePath))
            
            // Create attachment
            let attachment = try UNNotificationAttachment(
                identifier: "custom_image",
                url: URL(fileURLWithPath: filePath),
                options: [
                    UNNotificationAttachmentOptionsTypeHintKey: "public.png"
                ]
            )
            
            bestAttemptContent?.attachments = [attachment]
            NSLog("üîî NotificationService: ‚úÖ Image attachment created successfully")
            completion(true)
            
        } catch {
            NSLog("üîî NotificationService: ‚ùå Error creating image attachment: %@", error.localizedDescription)
            completion(false)
        }
    }
    
    // MARK: - Fallback and Completion
    
    private func fallbackToRegularNotification(content: UNMutableNotificationContent, request: UNNotificationRequest) {
        NSLog("üîî NotificationService: üì± Using fallback notification configuration")
        
        // Set basic content
        content.title = content.title.isEmpty ? "New Message" : content.title
        content.body = content.body.isEmpty ? "You have a new message" : content.body
        content.sound = content.sound ?? .default
        content.categoryIdentifier = "MESSAGE_CATEGORY"
        
        // Set thread identifier for grouping
        let conversationId = extractConversationId(from: request.content.userInfo)
        content.threadIdentifier = conversationId
        
        bestAttemptContent = content
        finishWithContent()
    }
    
    private func finishWithContent() {
        guard let contentHandler = contentHandler,
              let bestAttemptContent = bestAttemptContent else {
            NSLog("üîî NotificationService: ‚ùå No content handler or best attempt content")
            return
        }
        
        NSLog("üîî NotificationService: üèÅ Finishing with content")
        contentHandler(bestAttemptContent)
        self.contentHandler = nil
    }
}